#!/bin/bash

# As per freedesktop.org's XDG Base Directory Specification, all config files are stored in $XDG_CONFIG_HOME when set, or
# $HOME/.config when it isn't set. Theoretically, this variable could be used to maintain multiple feed files. This would be
# useful in the event that the user has two YouTube accounts they would prefer to keep separate. Technically, most of what I
# store here should probably go into $XDG_DATA_HOME (~/.local/share). We'll fix that eventually.
[ -z ${XDG_CONFIG_HOME} ] && XDG_CONFIG_HOME="${HOME}/.config"

# You should probably leave these variables alone, but in the event that you do mess with them, using ~/ in these variables
# causes problems.  Use $HOME or an absolute path instead.  Make sure the data dir contains only data. Don't put your subs file
# or feed in your data dir, for example.
DATA_DIR="${XDG_CONFIG_HOME}/ytsm/data"
FEED_DIR="${XDG_CONFIG_HOME}/ytsm/feed"
SUBS_FILE="${XDG_CONFIG_HOME}/ytsm/subscriptions"
CLIENT_DIR="${XDG_CONFIG_HOME}/ytsm/client"

# Color output. Customize with these color codes: http://www.tldp.org/HOWTO/Bash-Prompt-HOWTO/x329.html
BOLD=$(echo -n '[1m') # Used for the prompt.
GREEN=$(echo -n '[32m') # Used for the names of videos.
RED=$(echo -n '[1;31m') # Used for errors.
YELLOW=$(echo -n '[93m') # Used for the names of uploaders.
BOLD_YELLOW=$(echo -n '[1;33m') # Used for warnings.
RESET_COLOR=$(echo -n '[00m') # Resets color to the shell default.

DATE=$(date +%Y%m%d)

# If we don't use the full path of the feed file, it is possible that the daemon could run while the client is still up and
# cause the numbers to not line up with the actual videos (e.g., video four in today's feed might be video six in tomorrow's,
# so selecting video four would actually select video two because of an updated feed file). I'm using the GNU version of
# realpath, but most other versions (FreeBSD realpath, etc.) should work the same way.
FEED_FILE=$(realpath ${FEED_DIR}/feed)

# Report an error and abort execution on a missing feed file.
if [[ ! -f ${FEED_FILE} ]]; then
	echo "${RED}Error: no feed file present in ${FEED_DIR}. You probably haven't configured ytsm-cronjob yet.${RESET_COLOR}"
	exit 1
fi

# Pull data from config files. For now, that's just resolution info from youtube-viewer.
RESOLUTION=$(sed -e 's/#.*$//g' -e 's/"//g' -e 's/,$//' ${XDG_CONFIG_HOME}/youtube-viewer/youtube-viewer.conf | \
	awk '/resolution/ {printf $3}')

# youtube-viewer's --non-interactive flag was removed in yv 3.0.8 and replaced with a global variable set in the configuration
# file. If that variable is not set, we warn the user that the script will work, but that transitions between yv and ytsm
# won't be quite right.
if ! egrep -q '.*[^#].*interactive\s+=>\s+0' ${XDG_CONFIG_HOME}/youtube-viewer/youtube-viewer.conf; then
	echo ""
	echo "${BOLD_YELLOW}WARNING${RESET_COLOR}: 'interactive => 0' is not set in youtube-viewer.conf. ytsm will work"
	echo "as expected, but transitions between ytsm and youtube-viewer will not be"
	echo "completely seamless. This option is only present in youtube-viewer 3.0.8+."
	echo ""
fi

# Make the lastrun file if not present.
[[ ! -f "${CLIENT_DIR}/lastrun" ]] && echo ${DATE} > "${CLIENT_DIR}/lastrun"

LAST_DATE=$(cat ${CLIENT_DIR}/lastrun)

# This function generates the video list.
calculate_output() {
	# This cuts the feed file down to one line and two columns, then adds color and pretty formatting.
	OUTPUT=$(echo "${OUTPUT}" && echo -n "${i}. " && sed -e "${i}!d" -e 's/^\([^\t]*\t\)\{2\}//' -e "s/^/${GREEN}/" \
		-e "s/\\t/ ${YELLOW}\\(by /" -e "s/$/\\)${RESET_COLOR}/" ${FEED_FILE})
}

# This is a basic help screen. We should probably expand on it in the future.
if [[ $1 = "--help" ]] || [[ $1 = "-h" ]]; then
	echo "Run ytsm without an argument and type \"help\" at the prompt."
	exit
fi


# Loop until user says quit.
while [[ ${INPUT} != "q" ]] || [[ ${INPUT} != "quit" ]]; do

	# Grab user input. This prompt could probably be a bit more user friendly.
	echo "${BOLD}ytsm ready.${RESET_COLOR}"
	read -p " > " INPUT INPUT2

	if [[ ${INPUT} = "new" ]] || [[ ${INPUT} = "n" ]]; then
		# If current date is newer than the one in the lastrun file, print vids until the date is equal.
		# If not, then say "no new vids. Did you want all vids?"
		if [[ ${DATE} -gt ${LAST_DATE} ]]; then
			i=1
			# Loop over the file and print items, so long as they are newer than or as old as LAST_DATE.
			while [[ ${LAST_DATE} -lt $(sed -n ${i}p ${FEED_FILE} | cut -f 1) ]]; do
				calculate_output
				i=$(( i + 1 ))
			done

			# Prevents null output with no new uploads.
			if [[ -z ${OUTPUT} ]]; then
				echo "${RED}No new items.${RESET_COLOR} Maybe you want 'today' or 'top100' instead?\
					${RESET_COLOR}"
				continue
			fi
		else
			echo "${RED}No new items.${RESET_COLOR} Maybe you want 'today' or 'top100' instead?${RESET_COLOR}"
			continue
		fi
	elif [[ ${INPUT} = "all" ]] || [[ ${INPUT} = "a" ]]; then
		# Same as above, but dump the entire feed file. This is very, very slow with a lot of videos.
		i=1

		FEED_FILE_LINE_COUNT=$(wc -l ${FEED_FILE} | cut -d ' ' -f 1)

		while [[ ${i} -le ${FEED_FILE_LINE_COUNT} ]]; do
			calculate_output
			i=$(( i + 1 ))
		done
	elif [[ ${INPUT} = "today" ]] || [[ ${INPUT} = "t" ]]; then
		# Dumps only videos with today's date in the feed file.
		i=1
		while [[ ${DATE} -eq $(sed -n ${i}p ${FEED_FILE} | cut -f 1) ]]; do
			calculate_output
			i=$(( i + 1 ))
		done

		# Prevents null output with no new uploads.
		if [[ -z ${OUTPUT} ]]; then
			echo "${RED}No new items.${RESET_COLOR} Maybe you want 'top100' instead?\
				${RESET_COLOR}"
			continue
		fi
	elif [[ ${INPUT} = "week" ]] || [[ ${INPUT} = "w" ]]; then
		i=1
		# This code works with GNU date (part of GNU coreutils, which comes with GNU/Linux distros), but will probably
		# fail with BSD userland. This affects Linuxes with BSD userland (i.e., Linux without GNU), the BSDs and OS X.
		# If you don't know which date you have, see if 'date --version' mentions GNU coreutils.
		LAST_WEEK=$(date --date="-1 week" +%Y%m%d)

		# We use this extra check to prevent an unrecoverable hang when the while loop runs out of lines to index. This
		# only happens when the feed file is less than a week old.
		FEED_FILE_LINE_COUNT=$(wc -l ${FEED_FILE} | cut -d ' ' -f 1)

		while [[ $(cut -f 1 ${FEED_FILE} | sed -n ${i}p) -ge ${LAST_WEEK} ]] && [[ ${i} -le ${FEED_FILE_LINE_COUNT} ]]
			do
			calculate_output
			i=$(( i + 1 ))
		done
	elif [[ ${INPUT} = "top100" ]] || [[ ${INPUT} = "t100" ]]; then
		# Because processing 1200+ URLs is glacially slow, we have a top 100 fuction.
		i=1
		while [[ ${i} -le "100" ]]; do
			calculate_output
			i=$(( i + 1 ))
		done
	elif [[ ${INPUT} = "bench" ]] || [[ ${INPUT} = "b" ]]; then
		# This is exactly the same as the top100 function, but with a benchmark built in. Post processing is not
		# benchmarked, but that's less than 3% of the total time spent calculating on my system, even including the
		# benchmark calculations (it works out to 226ms vs. 220 ms). I have kept the benchmark contained to the bench
		# not-a-function-but-you-know-what-I-mean for the sake of simplicity.

		START_TIME=$(date +%s%N)
		i=1
		while [[ ${i} -le "100" ]]; do
			calculate_output
			i=$(( i + 1 ))
		done
		END_TIME=$(date +%s%N)

		# Based on info here: http://stackoverflow.com/questions/3683434/using-time-command-in-bash-script
		ELAPSED_TIME=$(( END_TIME - START_TIME )) # In nanoseconds.
		echo "${BOLD}Benchmark completed in ${ELAPSED_TIME}ns (${RED}$((ELAPSED_TIME/1000000))ms${RESET_COLOR}${BOLD})\
			${RESET_COLOR}"
	elif [[ ${INPUT} = yv* ]] || [[ ${INPUT} = youtube-viewer* ]]; then
		# Spawn a youtube-viewer instance with user-specified arguments. Note that the value checks in the above line are
		# not in quotes so that pash uses pattern matching rather than literal matching.
		YV_COMMAND=$(echo ${INPUT} | sed 's/^yv/youtube-viewer/')
		$(echo ${YV_COMMAND})
		continue
	elif [[ ${INPUT} = "update" ]] || [[ ${INPUT} = "u" ]]; then
		# Forces ytsm to reread the feed file and update it's internal date. This is possibly useful if ytsm was left
		# running overnight, because ytsm would write the previous date to disk when updating the lastrun file.
		DATE=$(date +%Y%m%d)
		FEED_FILE=$(realpath ${FEED_DIR}/feed)
		continue
	elif [[ ${INPUT} = "edit" ]] || [[ ${INPUT} = "e" ]]; then
		# Edit the subs file using $EDITOR. Use vi as a default if not defined.
		[[ ${EDITOR} ]] || EDITOR=vi
		${EDITOR} ${SUBS_FILE}
		continue
	elif [[ ${INPUT} = "addsub" ]] || [[ ${INPUT} = "as" ]]; then
		# Adds a sub to the subs file, optionally sorts. The <(echo) is a bashism, but it's also the easiest way to get
		# the job done. Another approach would be 'echo hi | cat $SUBS_FILE - | sort > $SUBS_FILE', but that's ugly.
		# We use $SUBS_FILE.1 to protect the file.
		if [[ -z ${INPUT2} ]]; then
			echo "${RED}No argument provided.${RESET_COLOR}"
			continue
		fi

		read -p "Sort subs file by name? [Yn] " SORTSUBS

		if [[ -z ${SORTSUBS} ]] || [[ ${SORTSUBS} = "y" ]]; then
			cat ${SUBS_FILE} <(echo ${INPUT2}) | sort > ${SUBS_FILE}.1
			mv ${SUBS_FILE}.1 ${SUBS_FILE}
		elif [[ ${SORTSUBS} = "n" ]]; then
			cat ${SUBS_FILE} <(echo ${INPUT2}) > ${SUBS_FILE}.1
			mv ${SUBS_FILE}.1 ${SUBS_FILE}
		fi
		continue
	elif [[ ${INPUT} = "delsub" ]] || [[ ${INPUT} = "ds" ]]; then
		# Same idea as addsub, but in reverse. We do some pattern matching to make sure we don't mess sed up.
		if [[ -z ${INPUT2} ]]; then
			echo "${RED}No argument provided.${RESET_COLOR}"
			continue
		elif echo ${INPUT2} | egrep -q -v "^[a-zA-Z0-9][-a-zA-Z0-9]*[a-zA-Z0-9]$"; then
			echo "${RED}ERROR${RESET_COLOR}: argument contains non-alphanumeric characters."
			continue
		fi

		read -p "${BOLD_YELLOW}WARNING${RESET_COLOR}: about to delete ${INPUT2}. Is this okay? [yN]" DEL_CONFIRM
		if [[ -z ${DEL_CONFIRM} ]] || [[ ${DEL_CONFIRM} = "n" ]]; then
			echo "Cancelling deletion."
			continue
		elif [[ ${DEL_CONFIRM} = "y" ]]; then
			sed -i "/^${INPUT2}$/d" ${SUBS_FILE}
		fi
		continue
	elif [[ ${INPUT} = "help" ]] || [[ ${INPUT} = "h" ]]; then
		echo "Valid commands:"
		echo " - new: print new videos."
		echo "        Synonym: n"
		echo " - all: print all videos. This can be very slow."
		echo "        Synonym: a"
		echo " - today: print all videos fetched today."
		echo "        Synonym: t"
		echo " - week: print all videos fetched this week."
		echo "        Synonym: w"
		echo " - top100: print the 100 most recently fetched videos."
		echo "        Synonym: t100"
		echo " - bench: run top100 with the inclusion of a simple benchmark."
		echo "        Synonym: b"
		echo " - youtube-viewer: run a yv instance with provided arguments."
		echo "        Synonym: yv"
		echo " - update: force an update of the date and feed file"
		echo "        Synonym: u"
		echo " - edit: edit the subscriptions file with \$EDITOR"
		echo "        Synonym: e"
		echo " - addsub: add a sub to the subs file"
		echo "        Synonym: as"
		echo " - delsub: delete a sub from the subs file"
		echo "        Synonym: ds"
		echo " - help: print this help."
		echo "        Synonym: h"
		echo " - quit: update the lastrun file and exit."
		echo "        Synonym: q"
		echo " - Control-C: exit without updating the lastrun file."
		echo ""
		echo "Further help is available at the vid prompt."
		continue
	elif [[ ${INPUT} = "q" ]] || [[ ${INPUT} = "quit" ]]; then
		break
	else
		echo "${RED}Syntax error: type 'help' for a list of valid commands.${RESET_COLOR}"
		INPUT=""
		continue
	fi

	# After the user picks one of ytsm's main operations, the output is paginated and displayed, and another prompt is
	# displayed that asks what ytsm should do next.
	while [[ ${INPUT} != "q" ]] || [[ ${INPUT} != "quit" ]]; do

		# Removes a blank line that appears before the video list. It's a consequence of the method we use to generate
		# the list.
		OUTPUT=$(echo "${OUTPUT}" | sed -e '/^$/d')

		# Calculate the range of items to show on each page and the number of pages.
		[[ -z ${PAGE} ]] && PAGE=1
		[[ -z ${TOTAL_PAGES} ]] && TOTAL_PAGES=$(echo "{$OUTPUT}" | wc -l) && TOTAL_PAGES=$(( TOTAL_PAGES / 25 ))
		[[ ${TOTAL_PAGES} = "0" ]] && TOTAL_PAGES=1
		OUT_MAX=$(( PAGE * 25 ))
		OUT_MIN=$(( OUT_MAX - 24 ))

		echo "${OUTPUT}" | sed -n ${OUT_MIN},${OUT_MAX}p
		echo "Page ${PAGE} of ${TOTAL_PAGES}"

		# Ask for input and run youtube-viewer if necessary.
		echo "${BOLD}Vid?${RESET_COLOR}"
		read -p " > " INPUT INPUT_ARG1 INPUT_ARG2

		# If INPUT_ARG1 is set, query for video info from youtube-viewer, then restart the loop.
		if [[ ${INPUT_ARG1} = "info" ]] || [[ ${INPUT_ARG1} = "i" ]]; then
			youtube-viewer --resolution=${RESOLUTION} --info $(cut -f 2 ${FEED_FILE} | sed -n ${INPUT}p)
			echo ""
			echo "${BOLD}Press Enter to continue.${RESET_COLOR}"
			read -p ""
			continue
		elif [[ ${INPUT_ARG1} = "comments" ]] || [[ ${INPUT_ARG1} = "c" ]]; then
			# No "Press Enter" prompt on this one because yv does it by itself.
			youtube-viewer --resolution=${RESOLUTION} --comments $(cut -f 2 ${FEED_FILE} | sed -n ${INPUT}p)
			echo ""
			continue
		elif [[ ${INPUT_ARG1} = "author" ]] || [[ ${INPUT_ARG1} = "a" ]]; then
			# If the user asks, display playlists by the author of the chosen playlists. If the user doesn't ask,
			# show the author's main video page instead.
			if [[ ${INPUT_ARG2} = "playlists" ]] || [[ ${INPUT_ARG2} = "p" ]]; then
				youtube-viewer --resolution=${RESOLUTION} --user-pl $(cut -f 4 ${FEED_FILE} | sed -n ${INPUT}p)
			else
				youtube-viewer --resolution=${RESOLUTION} --user $(cut -f 4 ${FEED_FILE} | sed -n ${INPUT}p)
			fi
			echo ""
			continue
		elif [[ ${INPUT_ARG1} = "download" ]] || [[ ${INPUT_ARG1} = "d" ]]; then
			# Pretty simple command. Download the file to $PWD if the user asks us to. Eventually, we should add support for
			# yv --download --ffmpeg-command.
			youtube-viewer --download $(cut -f 2 ${FEED_FILE} | sed -n ${INPUT}p)
			continue
		fi

		# These commands are separate from the above because they don't rely on secondary arguments (INPUT_ARG1, etc.).
		if [[ ${INPUT} = "n" ]] || [[ ${INPUT} = "next" ]]; then
			# Go to next page.
			PAGE=$(( PAGE + 1 ))
			if [[ ${PAGE} -gt ${TOTAL_PAGES} ]]; then
				PAGE=${TOTAL_PAGES}
			fi
			continue
		elif [[ ${INPUT} = "p" ]] || [[ ${INPUT} = "previous" ]]; then
			# Go to previous page.
			PAGE=$(( PAGE - 1 ))
			if [[ ${PAGE} -lt "1" ]]; then
				PAGE=1
			fi
			continue
		elif [[ ${INPUT} = "reso" ]] || [[ ${INPUT} = "r" ]]; then
			# This is a resolution picker. The default comes from the user's youtube-viewer.conf.
			echo "${BOLD}Current resolution: ${RESOLUTION}. Enter a new resolution:${RESET_COLOR}"
			read -p " > " INPUT
			if [[ ${INPUT} = "original" ]] || [[ ${INPUT} = "1080" ]] || [[ ${INPUT} = "720" ]] \
				|| [[ ${INPUT} = "480" ]] || [[ ${INPUT} = "360" ]] || [[ ${INPUT} = "340" ]] \
				|| [[ ${INPUT} = "240" ]] || [[ ${INPUT} = "180" ]] || [[ ${INPUT} = "144" ]]; then
				RESOLUTION=${INPUT}
			elif [[ -z ${INPUT} ]]; then
				echo "${BOLD_YELLOW}Not changing resolution.${RESET_COLOR}"
				sleep 1
			else
				echo "${RED}Error: bad resolution.${RESET_COLOR}"
				sleep 1
			fi
			continue
		elif [[ ${INPUT} = "help" ]] || [[ ${INPUT} = "h" ]]; then
			echo "Vid prompt help."
			echo ""
			echo "Valid commands:"
			echo " - <number>: play a video. <number> refers to an item number in the vid list."
			echo " - <number> info: query youtube-viewer for info on video <number>."
			echo "        Synonym: <number> i"
			echo " - <number> comments: use youtube-viewer to view comments for video <number>."
			echo "        Synonym: <number> c"
			echo " - <number> author: display videos by the author of video <number>."
			echo "        Append \"playlists\" or \"p\" to display playlists instead of uploads."
			echo "        Synonym: \"<number> a\", \"<number> a p\""
			echo " - <number> download: download the video to the current directory."
			echo "        Synonym: <number> d"
			echo " - next: display the next page."
			echo "        Synonym: n"
			echo " - p: display the previous page."
			echo "        Synonym: p"
			echo " - reso: change the resolution youtube-viewer requests from YouTube. Pick one of"
			echo "         the following: original, 1080, 720, 480, 360, 340, 240, 180, 144."
			echo "        Synonym: r"
			echo " - help: print this help."
			echo "        Synonym: h"
			echo " - quit: return to the previous prompt."
			echo "        Synonym: q"
			echo " - Control-C: exit without updating the lastrun file."
			echo ""
			# We add a prompt here so that the help isn't lost above the list of videos.
			echo "${BOLD}Press Enter to continue.${RESET_COLOR}"
			read -p ""
			continue
		elif [[ ${INPUT} = "q" ]] || [[ ${INPUT} = "quit" ]]; then
			# Reset all relevant variables and return to the first prompt.
			INPUT=""
			OUTPUT=""

			PAGE=""
			TOTAL_PAGES=""
			PAGE_MIN=""
			PAGE_MAX=""

			continue 2
		else
			if ! [[ ${INPUT} =~ ^[0-9]+$ ]]; then
				echo "${RED}Syntax error: type 'help' for a list of valid commands.${RESET_COLOR}"
				sleep 1
				continue
			elif [[ ${INPUT} -gt $(echo "${OUTPUT}" | wc -l) ]]; then
				echo "${RED}Error: number out of range.${RESET_COLOR}"
				sleep 1
				continue
			fi
			youtube-viewer --resolution=${RESOLUTION} $(cut -f 2 ${FEED_FILE} | sed -n ${INPUT}p)
		fi
	done
	
done

# Update the lastrun file. Set the file to a few days ago and comment out this line if you are debugging "new".
echo ${DATE} > ${CLIENT_DIR}/lastrun
